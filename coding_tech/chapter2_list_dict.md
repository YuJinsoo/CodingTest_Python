# 목록
1. [BetterWay11: 시퀀스를 슬라이싱 하는 방법을 익혀라](#betterway-11-스퀀스를-슬라이싱하는-방법을-익혀라)
2. [BetterWay12: 라](#)
3. [BetterWay13: bytes와 str의 차이를 알아두라](#)
4. [BetterWay14: c스타일 형식 문자열을 strformat과 쓰기보다는 f-문자열 을 통한 인터폴레이션을 사용해라]()
5. [BetterWay15: 복성해라]()
6. [BetterWay16: 인패킹해라]()
7. [BetterWay17: ra용하라]()
8. [BetterWay18: 여러 수행하려면 zip을 사용해라]()
9. [BetterWay19: fo록을 사용하지 말아라](라)
10. [BetterWay20:  사용해 반복을 피해라]()


# Chapter2 : 리스트와 딕셔너리

- 반복적인 작업을 자동화할 때 조직적으로 관리하는 가장 일반적인 방법은 `list`를 사용하는 것입니다.
    - 아주 간편하며 다양한 문제 해결 가능합니다.
- `list`를 보완하는 것이 딕셔너리 `dictionary` 입니다.
    - 검색에 사용할 키와 키에 연관된 값을 저장합니다.
    - 일반적으로 **해시테이블** 이나 **연관 배열** 이라고 부르는 구조 안에 저장합니다.
    - 분할상환 복잡도로 상수 시간에 원소를 삽입하고 찾을 수 있습니다.
    - 그렇기 때문에 동적인 정보를 관리하는데 `dictionary`가 가장 이상적입니다.
<br>

## BetterWay 11. 스퀀스를 슬라이싱하는 방법을 익혀라

- 시퀀스를 여러 조각으로 나누는 `슬라이싱` 문법을 지원합니다.
- 어떤 파이썬 클래스에도 슬라이싱을 추가할 수 있습니다.
    - `__getitem__`과 `__setitem__`을 구현해주면 됩니다.

<br>

- 슬라이싱 구문의 기본 형태는 `리스트[시작:끝]`
    - `시작` 인덱스는 포함
    - `끝` 인덱스는 포함되지 않음
    - 맨 앞부터 시작할 때에는 굳이 `0`을 넣지 않습니다.
    - 길이 끝까지 슬라이싱 할 때에는 `끝`에 아무것도 넣지 않습니다.

```python
a = ['a','b','c','d','e','f','g','h']
print('가운데 2개:', a[3:5]) # 가운데 2개: ['d', 'e']
print('마지막을 제외한 나머지:', a[0:7]) # 마지막을 제외한 나머지: ['a', 'b', 'c', 'd', 'e', 'f', 'g']

## 시작할때는 0을 넣지 않고 끝까지 할 때에는 마지막을 넣지 않음
assert a[0:5] == a[:5]
assert a[3:len(a)] == a[3:]
```

- 다양한 슬라이싱 방법
    - 음수 값으로 슬라이싱이 가능합니다.
    - 하지만 인덱싱을 음수로 하면 에러가 발생하니 주의합니다. (슬라이싱: [:], 인덱싱: [])
    - 전체 슬라이싱은 시작, 끝에 아무값도 넣지 않습니다.
    - 시퀀스의 범위를 넘어가도 슬라이싱이 가능합니다. 유효한 부분까지만 선택됨

```python
a = ['a','b','c','d','e','f','g','h']

print(a[:])     # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
print(a[:5])    # ['a', 'b', 'c', 'd', 'e']
print(a[:-1])   # ['a', 'b', 'c', 'd', 'e', 'f', 'g']
print(a[4:])    #                     ['e', 'f', 'g', 'h']
print(a[-3:])   #                          ['f', 'g', 'h']
print(a[2:5])   #           ['c', 'd', 'e']
print(a[2:-1])  #           ['c', 'd', 'e', 'f', 'g']
print(a[-3:-1]) #                          ['f', 'g']
print(a[:20])   # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
print(a[-20:])  # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
```
<br>

- 리스트를 슬라이싱한 결과는 완전히 새로운 리스트입니다. (슬라이싱 결과로 얻은 리스트를 변경해도 원본은 보존)
- 슬라이싱으로 지정된 부분에 다른 리스트를 대입하면 슬라이싱으로 선택된 부분이 대입하는 리스트로 변경됩니다.(대입하는 리스트의 길이와는 무관합니다.)

```python
## 슬라이싱으로 쪼갠 리스트를 변수에 할당하면
## 원래 리스트와는 별개의 리스트입니다.
a = ['a','b','c','d','e','f','g','h']

b = a[:3]
print('인덱싱 할당 이전:', b)
b[1] = 99 # 하나에 할당
print('인덱싱 할당 이후:', b)
print('원본(변화없음):', a)

# 인덱싱 할당 이전: ['a', 'b', 'c']
# 인덱싱 할당 이후: ['a', 99, 'c']
# 원본(변화없음): ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

## 슬라이싱으로 지정한 부분에 다른 리스트를 대입해보자
# 대입되는 리스트 값과 슬라이싱 부분의 길이는 관계없습니다.
a = ['a','b','c','d','e','f','g','h']
print('슬라이싱 할당 이전:', a)
a[2:7] = [99, 22, 14]
print('슬라이싱 할당 이후:', a)
# 슬라이싱 할당 이전: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
# 슬라이싱 할당 이후: ['a', 'b', 99, 22, 14, 'h']
```
<br>

- 슬라이싱으로 전체 리스트를 복사한 case를 살펴봅시다.
    - `=`으로 할당하면 얕은복사라서 같은 list
    - 슬라이싱으로 할당하면 깊은복사라서 다른 list

```python
a = ['a','b','c','d','e','f','g','h']
b = a[:] ## 전체 리스트 복사 값은 같지만 다른 list
assert b == a and b is not a
print('a id:', id(a)) # a id: 1996685917440
print('b id:', id(b)) # b id: 1996685924672

## 얕은복사 되어서 같은 list를 가리키는 상황
b = a 
print('이전 a:', a)  # 이전 a: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
print('이전 b:', b)  # 이전 b: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
a[:] = [101, 102, 103]
assert a is b
print('이후 a:', a)   # 이후 a: [101, 102, 103]
print('a id:', id(a)) # a id: 1941179284736
print('b id:', id(b)) # b id: 1941179284736
```
<br>

### 기억해야 할 Point
> - 슬라이싱할 때는 간결하게 합니다. (시작 인덱스에 0 이나 끝 인덱스에 시퀀스 길이를 넣지 않습니다.)<br>
> - 슬라이싱은 범위를 넘어가는 시작 인덱스나 끝 인덱스도 허용합니다. 시퀀스의 시작이나 끝에서 길이를 제한하는 슬라이스를 쉽게 표현할 수 있습니다.<br>
> - 리스트 슬라이스에 대입하면 원래 시퀀스에서 슬라이스가 가리키는 부분을 대입 연산자 오른쪽(대입하는 값) 시퀀스로 대체합니다. 이때 대입하는 값의 길이는 슬라이싱한 것과 길이가 달라도 됩니다.<br>

## BetterWay 12. 스트라이드와 슬라이스를 한 식에 함께 사용하지 말라

- 파이썬은 `[시작:끝:증가값]`으로 증가값으로 지정한 일정한 간격을 두고 슬라이싱을 할 수 있는 **스트라이드 구문**을 지원합니다.
    - 스트라이드를 사용해 짝수번째 그룹와 홀수번째 그룹을 쉽게 나눌 수 있습니다.
- 종종 예기치 못한 버그를 발생시킵니다.
    - `증가값`을 -1로 사용해 문자열을 뒤집는 경우
        - 바이트 문자열 가능
        - 유니코드 문자열 가능
        - utf-8로 인코딩한 문자열은 불가능

```python
x = ['빨','주','노','초','파','남','보']
odd = x[::2]    # ['빨', '노', '파', '보']
even = x[1::2]  # ['주', '초', '남']

## 문자열 거구로 예제. 유니코드 문자는 몰라서...
x = b'mongoose'
y = x[::-1]
print(y)

w = '스시'
x = w.encode('utf-8')
y = x[::-1]
z = y.decode('utf-8')
# Traceback (most recent call last):
#   File "c:\Users\ABO\Desktop\Study_Python\coding_tech\chapter2_list_dict.py", line 70, in <module>
#     z = y.decode('utf-8')
# UnicodeDecodeError: 'utf-8' codec can't decode byte 0x9c in position 0: invalid start byte
```
<br>

> 왜냐하면 `utf-8` 인코딩은 멀티바이트 문자 형식으로 바이트 순서를 뒤집으면 2바이트 이상으로 구성된 문자들은 코드가 깨지게 됩니다. 단, `ascii code` 범위의 문자열로 이루어졌다면 모두 1바이트이기 떄문에 `utf-8`로 인코딩된 문자열 이더라도 오류가 발생하지 않습니다. 

<br>

- 중요한 점은 슬라이싱 구문에 스트라이딩까지 들어가면 매우 혼란스럽습니다.
- 그렇기 때문에 시작, 끝, 증가값 세 파라미터 모두를 한 번에 사용하는 것을 지양합니다.

<br>

- 스트라이딩 한 다음 슬라이싱을 하면 데이터를 한 번 더 얕게 복사하게 됩니다.
    - 첫 번째 연산(스트라이딩)은 결과 시퀀스의 크기를 가능한 한 줄일 수 있어야 합니다.
    - 두 번째연산에서는 슬라이싱을 통해 원하는 범위를 선택합니다.

```python
x = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
print(x[::2])       # ['a', 'c', 'e', 'g']
print(x[::-2])      # ['h', 'f', 'd', 'b']

print(x[2::2])      # ['c', 'e', 'g']
print(x[-2:2:-2])   # ['g', 'e']
print(x[2:2:-2])    # []

# 스트라이딩한 것을 얕은복사, 그리고 슬라이싱
y = x[::2] # ['a', 'c', 'e', 'g']
z = y[1:-1] # ['c', 'e']
```
<br>

- 만약 시퀀스가 너무 길어 연산에 필요한 시간과 메모리를 감당할 수 없다면 `itertools`내장 모듈의 `islice`메서드 사용을 고려합니다. --> BetterWay36

<br>

### 기억해야 할 Point
> - 슬라이스에 시작, 끝, 증가값을 함께 지정하면 코드의 의미를 혼동하기 쉽습니다.<br>
> - 시작이나 끝 인덱스가 없는 슬라이스를 만들 때는 양수 증가값을 사용하라. 가급적 음수 증가값은 피하세요.<br>
> - 한 슬라이스 안에서 시작, 끝, 증가값을 함께 사용하지 않습니다. 세 파라미터를 모두 사용해야 하는 경우 두 번 대입을 사용(한 번은 스트라이딩, 한 번은 슬라이싱) 하거나 itertools내장 모듈의 islice를 사용하세요. <br>
> - <br>

## BetterWay 13. 슬라이싱보다는 나머지를 모두 잡아내는 언패킹을 사용하라
### 기억해야 할 Point
> - <br>
> - <br>
> - <br>

## BetterWay 14. 복잡한 기준을 사용해 정렬할 때에는 key 파라미터를 사용하라
### 기억해야 할 Point
> - <br>
> - <br>
> - <br>

## BetterWay 15. 딕셔너리 삽입 순서에 의존할 때는 조심하라
### 기억해야 할 Point
> - <br>
> - <br>
> - <br>

## BetterWay 16. in을 사용하고 딕셔너리 키가 없을 때 KeyError를 처리하기 보다는 get을 사용하라
### 기억해야 할 Point
> - <br>
> - <br>
> - <br>

## BetterWay 17. 내부 상태에서 원소가 없는 경우를 처리할 때는 setdefault보다 defaultdict를 사용하라
### 기억해야 할 Point
> - <br>
> - <br>
> - <br>

## BetterWay 18. __missing__을 사용해 키에 따라 다른 디폴트 값을 생성하는 방법을 아라두라
### 기억해야 할 Point
> - <br>
> - <br>
> - <br>
